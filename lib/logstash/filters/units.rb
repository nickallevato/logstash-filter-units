# encoding: utf-8

require "logstash/filters/base"
require "logstash/namespace"
require "unitwise"

# The units filter is used for converting specified fields from one 
# unit of measure to another (or many others).

class LogStash::Filters::Units < LogStash::Filters::Base
	config_name "units"
	milestone 1
	
	config(:fields, :validate => :array, :required => true)
	# The source fields to be converted
	# Fields may be specified in three different ways:
	# - Fields may be referenced specifically, by drilling
	#   down the field hierarchy using the square bracket syntax. If
	#   they are specified in this manner, then only the exact field
	#   specified will be converted.
	# - Fields may also be specifed more generally simply by proving
	#   the field name.  If done this way, the given field will convert
	#   any bottom level field of the same name.
	# - If provided a string rather than an array of fields, the field
	#   provided will be converted in place rather then prepended with
	#   additional fields.
	# Example:
	# [source,ruby]
	# 	filter {
	# 		units {
	# 			fields => ["top_level_field",
	#					   "bottom_level_field",
	# 					   "[a][nested][field]"]
	# 			output_units => ["kilobyte", "megabyte"]
	# 		}
	# 	}
	# Example:
	# [source,ruby]
	# 	filter {
	# 		units {
	# 			fields => "in_place_conversion"
	# 			output_units => ["megabyte"]
	# 		}
	# 	}

	config(:input_unit, :validate => :string, :default => "byte")
	# The unit of measure of the source fields to be converted.
	# This parameter supports all units of measure specified by
	# the unitwise gem.
	# http://github.com/joshwlewis/unitwise
	# Example:
	# [source,ruby]
	# 	filter {
	# 		units {
	#			fields => ["length", "height"]
	# 			input_unit => "millimeter"
	# 			output_units => ["centimeter", "meter"]
	# 		}
	# 	}

	config(:output_units, :required => true)
	# The units of measure used for conversion.
	# This parameter supports all units of measure specified by
	# the unitwise gem.
	# http://github.com/joshwlewis/unitwise
	# By default, new fields will be named according to these units.
	# Example:
	# [source,ruby]
	# 	filter {
	# 		units {
	#			fields => ["length", "height"]
	# 			input_unit => "millimeter"
	# 			output_units => ["centimeter", "meter"]
	# 		}
	# 	} 

	config(:root_field, :validate => :string)
	# If specified, the fields generated by the filter will be
	# placed within a hierarchy mirroring that of the fields
	# listed within the fields parameter, which is itself nested
	# under the given root field.
	# For example, with this config:
	# [source,ruby]
	# 	filter {
	# 		units {
	#			fields => ["c"]
	# 			input_unit => "byte"
	# 			output_units => ["kilobyte", "megabyte"]
	# 			root_field => "special"
	# 		}
	# 	}
	#
	# {
	# 	"a" => {
	# 		"b" => {
	# 			"c" => 1000000
	#     	}
	# 	}
	# }
	#
	# becomes
	#
	# {
	# 	"a" => {
	# 		"b" => {
	# 			"c" => 1000000
	#     	}
	# 	},
	# 	"special" => {
	# 		"a" => {
	# 			"b" => {
	# 				"c" => {
	# 					"kilobyte" => 1000,
	#					"megabyte" => 1
	#				}
	#   	  	}
	# 		}
	# 	}
	# }

	config(:rename_labels, :validate => :hash, :default => {})
	# Renames the resulting output fields according to a hash.
	# Keys should be the output fields and values should be their
	# desired names, respectively.  Unamed fields will persist.
	# Example:
	# [source,ruby]
	# 	filter {
	# 		units {
	#			fields => ["file_size"]
	# 			input_unit => "byte"
	# 			output_units => ["kilobyte", "megabyte"]
	# 			rename_labels => {
	# 				"kilobyte" => "kB"
	# 				"megabyte" => "mB"
	# 			}
	# 		}
	# 	} 

	def initialize(*args)
		super(*args)
	end

	public
	def register()
	end

	private
	def nested_hash_to_matrix(data)
		@sep = '.'
		@output = []
		def _nested_hash_to_matrix(data, name)
			data.each do |key, val|
				new_key = name + @sep + key.to_s
				if val.is_a?(Hash) and val != {}
					_nested_hash_to_matrix(val, new_key)
				else
					@output.push([new_key, val])
				end
			end
			return @output
		end

		@output = _nested_hash_to_matrix(data, @sep)
		@output = @output.map { |key, val| [key.split('.')[2..-1], val] }
		return @output
	end

	private
	def matrix_to_nested_hash(data)
		output = {}
		data.each do |keys, value|
			cursor = output
			for key in keys[0..-2]
				if !cursor.include?(key)
					cursor[key] = {}
					cursor = cursor[key]
				else
					cursor = cursor[key]
				end
			end
			cursor[keys[-1]] = value
		end
		return output
	end

	private
	def convert_to_dict(value)
		# convert a single value to a hash of converted values
		output = {}
		for output_unit in @output_units do
			output_value = convert(value, output_unit)
			if @rename_labels.include?(output_unit)
				output_unit = @rename_labels[output_unit]
			end
			output[output_unit] = output_value
		end
		return output
	end

	private
	def convert(value, output_unit)
		begin
			return output_value = Unitwise(value, @input_unit).convert_to(output_unit).value
		rescue Exception
			raise StandardError
		end
	end

	private
	def field_handler(fields)
		output = {"exact" => [], "partial" => []}
		for field in fields
			if /\[|\]/.match(field)
				temp = field.split(/\]\[|^\[|\]$/)[1..-1]
				output["exact"].push(temp)
			else
				output["partial"].push(field)
			end
		end
		return output
	end

	public
	def filter(event)
		return unless filter?(event)
		begin
			# flag for converting a value in place or expanding it into
			# a hash
			inplace = @output_units.is_a?(String)
			matrix = nested_hash_to_matrix(event.to_hash)		

			# convert matching fields and  remove rows that
			# do not contain leaf nodes that match @fields
			fields = field_handler(@fields)
			del = []
			matrix.each do |row|
				if fields["exact"].include?(row[0])
					if inplace
						row[1] = convert(row[1], @output_units)
					else
						row[1] = convert_to_dict(row[1])
					end
				elsif fields["partial"].include?(row[0][-1])
					if inplace
						row[1] = convert(row[1], @output_units)
					else
						row[1] = convert_to_dict(row[1])
					end
				else
					del.push(row)
				end
			end
			# delete all rows that do not have leaf nodes listed
			# in fields
			for row in del
				matrix.delete(row)
			end
			
			new_hash = matrix_to_nested_hash(matrix)
			if @root_field
				new_hash = {@root_field => new_hash}
			end

			# merge new hash into event's hash
			# assignment of items from new_hash with a prior merge
			# will destroy unmatched branches
			data = event.to_hash().merge(new_hash)
   			data.each do |key, value|
				event[key] = value
			end
			return filter_matched(event)
		rescue StandardError
			event.tag("_unitsparsefailure")
			return event
		rescue Logstash::ShutdownSignal
			event.cancel()
			@logger.debug(e)
		end
	end
end